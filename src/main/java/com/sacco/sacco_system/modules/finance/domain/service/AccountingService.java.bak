package com.sacco.sacco_system.modules.finance.domain.service;
import com.sacco.sacco_system.modules.admin.domain.entity.Asset;
import com.sacco.sacco_system.modules.finance.domain.entity.accounting.GLAccount;
import com.sacco.sacco_system.modules.finance.domain.entity.accounting.GlMapping;
import com.sacco.sacco_system.modules.finance.domain.entity.accounting.JournalEntry;
import com.sacco.sacco_system.modules.finance.domain.entity.accounting.JournalLine;
import com.sacco.sacco_system.modules.savings.domain.entity.Withdrawal;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sacco.sacco_system.modules.finance.domain.entity.accounting.*;
import com.sacco.sacco_system.modules.finance.domain.repository.*;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.InputStream;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import com.sacco.sacco_system.modules.finance.domain.service.AccountingService;
import com.sacco.sacco_system.modules.loan.domain.entity.Loan;
import com.sacco.sacco_system.modules.member.domain.entity.Member;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountingService {

    private final GLAccountRepository accountRepository;
    private final JournalEntryRepository journalRepository;
    private final JournalLineRepository journalLineRepository;
    private final GlMappingRepository glMappingRepository;
    private final FiscalPeriodRepository fiscalPeriodRepository;
    private final ObjectMapper objectMapper;

    /**
     * âœ… DYNAMIC POSTING: Looks up account codes from the database configuration.
     * Keeps your business logic flexible.
     */
    @Transactional
    public void postEvent(String eventName, String description, String referenceNo, BigDecimal amount) {
        GlMapping mapping = glMappingRepository.findByEventName(eventName)
                .orElseThrow(() -> new RuntimeException("GL Mapping not found for event: " + eventName));

        postDoubleEntry(description, referenceNo, mapping.getDebitAccountCode(), mapping.getCreditAccountCode(), amount);
    }

    @Transactional
    public void postDoubleEntry(String description, String referenceNo, String debitAccountCode, String creditAccountCode, BigDecimal amount) {
        checkFiscalPeriod(LocalDate.now());

        GLAccount debitAcct = glAccountRepository.findByAccountCode(debitAccountCode)
                .orElseThrow(() -> new RuntimeException("Debit Account not found: " + debitAccountCode));

        GLAccount creditAcct = glAccountRepository.findByAccountCode(creditAccountCode)
                .orElseThrow(() -> new RuntimeException("Credit Account not found: " + creditAccountCode));

        JournalEntry entry = JournalEntry.builder()
                .transactionDate(LocalDateTime.now())
                .description(description)
                .referenceNo(referenceNo)
                .build();

        JournalLine debitLine = JournalLine.builder().journalEntry(entry).account(debitAcct).debit(amount).credit(BigDecimal.ZERO).build();
        JournalLine creditLine = JournalLine.builder().journalEntry(entry).account(creditAcct).debit(BigDecimal.ZERO).credit(amount).build();

        entry.setLines(List.of(debitLine, creditLine));

        updateBalance(debitAcct, amount, true);
        updateBalance(creditAcct, amount, false);

        journalRepository.save(entry);
    }

    private void checkFiscalPeriod(LocalDate date) {
        fiscalPeriodRepository.findByActiveTrue().ifPresent(period -> {
            if (period.isClosed()) {
                throw new RuntimeException("Fiscal Period is closed. No new transactions allowed.");
            }
        });
    }

    @Transactional
    public void postManualJournalEntry(ManualEntryRequest request) {
        checkFiscalPeriod(request.getDate());

        BigDecimal totalDebit = request.getLines().stream().map(ManualEntryLine::getDebit).reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalCredit = request.getLines().stream().map(ManualEntryLine::getCredit).reduce(BigDecimal.ZERO, BigDecimal::add);

        if (totalDebit.compareTo(totalCredit) != 0) {
            throw new RuntimeException("Journal Entry is unbalanced! Total Debit: " + totalDebit + ", Total Credit: " + totalCredit);
        }

        JournalEntry entry = JournalEntry.builder()
                .transactionDate(request.getDate().atStartOfDay())
                .postedDate(LocalDateTime.now())
                .description(request.getDescription())
                .referenceNo(request.getReference())
                .lines(new ArrayList<>())
                .build();

        for (ManualEntryLine lineDto : request.getLines()) {
            GLAccount account = accountRepository.findById(lineDto.getAccountCode())
                    .orElseThrow(() -> new RuntimeException("Account not found: " + lineDto.getAccountCode()));

            JournalLine line = JournalLine.builder()
                    .journalEntry(entry)
                    .account(account)
                    .debit(lineDto.getDebit())
                    .credit(lineDto.getCredit())
                    .build();
            entry.getLines().add(line);

            if (lineDto.getDebit().compareTo(BigDecimal.ZERO) > 0) updateBalance(account, lineDto.getDebit(), true);
            else updateBalance(account, lineDto.getCredit(), false);
        }
        journalRepository.save(entry);
    }

    private void updateBalance(GLAccount account, BigDecimal amount, boolean isDebit) {
        if (account.getType() == AccountType.ASSET || account.getType() == AccountType.EXPENSE) {
            account.setBalance(isDebit ? account.getBalance().add(amount) : account.getBalance().subtract(amount));
        } else {
            account.setBalance(isDebit ? account.getBalance().subtract(amount) : account.getBalance().add(amount));
        }
        accountRepository.save(account);
    }

    public BigDecimal getAccountBalance(String glCode) {
        // Use 'accountRepository' (the name defined at the top of your file)
        GLAccount account = accountRepository.findById(glCode)
                .orElseThrow(() -> new RuntimeException("GL Account not found: " + glCode));

        return account.getBalance();
    }

    @Data
    public static class ManualEntryRequest {
        private String description;
        private String reference;
        private LocalDate date;
        private List<ManualEntryLine> lines;
    }

    @Data
    public static class ManualEntryLine {
        private String accountCode;
        private BigDecimal debit = BigDecimal.ZERO;
        private BigDecimal credit = BigDecimal.ZERO;
    }

    @Transactional
    public GLAccount toggleAccountStatus(String code) {
        GLAccount account = accountRepository.findById(code).orElseThrow(() -> new RuntimeException("Account not found"));
        account.setActive(!account.isActive());
        return accountRepository.save(account);
    }

    @Transactional
    public GLAccount createManualAccount(GLAccount account) {
        if (accountRepository.existsById(account.getCode())) throw new RuntimeException("Account code already exists.");
        account.setBalance(BigDecimal.ZERO);
        account.setActive(true);
        return accountRepository.save(account);
    }

    public List<GLAccount> getAccountsWithBalancesAsOf(LocalDate startDate, LocalDate endDate) {
        List<GLAccount> allAccounts = accountRepository.findAll();
        List<Object[]> totals = (startDate == null)
                ? journalLineRepository.getAccountTotalsUpToDate(endDate.atTime(LocalTime.MAX))
                : journalLineRepository.getAccountTotalsInRange(startDate.atStartOfDay(), endDate.atTime(LocalTime.MAX));

        for (GLAccount account : allAccounts) {
            BigDecimal debitSum = BigDecimal.ZERO;
            BigDecimal creditSum = BigDecimal.ZERO;

            for (Object[] row : totals) {
                if (row[0].equals(account.getCode())) {
                    debitSum = (row[1] != null) ? (BigDecimal) row[1] : BigDecimal.ZERO;
                    creditSum = (row[2] != null) ? (BigDecimal) row[2] : BigDecimal.ZERO;
                    break;
                }
            }
            BigDecimal netBalance = (account.getType() == AccountType.ASSET || account.getType() == AccountType.EXPENSE)
                    ? debitSum.subtract(creditSum) : creditSum.subtract(debitSum);
            account.setBalance(netBalance);
        }
        return allAccounts;
    }

    public void initChartOfAccounts() {
        if(accountRepository.count() == 0) {
            try {
                log.info("ðŸ“‚ Loading Chart of Accounts from JSON...");
                InputStream inputStream = new ClassPathResource("accounts.json").getInputStream();
                List<GLAccount> accounts = objectMapper.readValue(inputStream, new TypeReference<List<GLAccount>>(){});
                for (GLAccount account : accounts) {
                    account.setBalance(BigDecimal.ZERO);
                    account.setActive(true);
                    accountRepository.save(account);
                }
                initDefaultMappings();
                log.info("âœ… Successfully initialized {} GL Accounts.", accounts.size());
            } catch (Exception e) {
                log.error("âŒ Failed to load accounts.json: {}", e.getMessage(), e);
            }
        }
    }

    public void initDefaultMappings() {
        createMapping("LOAN_DISBURSEMENT", "1200", "1001", "Loan Disbursement");
        createMapping("LOAN_REPAYMENT", "1001", "1200", "Loan Repayment");
        createMapping("SAVINGS_DEPOSIT", "1001", "2001", "Member Deposit");
        createMapping("SAVINGS_WITHDRAWAL", "2001", "1001", "Member Withdrawal");
        createMapping("INTEREST_EARNED", "5006", "2002", "Interest on Savings");
        createMapping("PENALTY_CHARGED", "1200", "4001", "Penalty Charged");
        createMapping("PROCESSING_FEE", "1001", "4000", "Processing Fee");
        createMapping("WRITE_OFF", "5011", "1200", "Bad Debt Write-off");
        createMapping("ASSET_PURCHASE", "1500", "1001", "Asset Purchase");
    }

    private void createMapping(String event, String dr, String cr, String desc) {
        if (glMappingRepository.findById(event).isEmpty()) {
            glMappingRepository.save(new GlMapping(event, dr, cr, desc));
            log.info("âœ… Created missing GL Mapping: {}", event);
        }
    }
}





